<?php
require_once __DIR__ . '/../../includes/db.php';
require_once __DIR__ . '/../../includes/auth.php';

$db = db();
require_role(['Admin','Encoder','Inspector']);

header('Content-Type: application/json');

$isCli = (php_sapi_name() === 'cli');
if (!$isCli && $_SERVER['REQUEST_METHOD'] !== 'GET') {
    echo json_encode(['ok'=>false, 'error'=>'invalid_method']);
    exit;
}

$lookback = (int)($_GET['lookback_hours'] ?? ($isCli ? 168 : 168));
$gran = (int)($_GET['granularity_min'] ?? 60);
$granSec = max(60, $gran) * 60;

// 1. Find all terminal/route pairs with forecasts in the lookback window
$pairsQuery = "
    SELECT DISTINCT terminal_id, route_id 
    FROM demand_forecasts 
    WHERE ts >= DATE_SUB(NOW(), INTERVAL ? HOUR) 
    AND ts <= NOW()
";
$stmt = $db->prepare($pairsQuery);
$stmt->bind_param('i', $lookback);
$stmt->execute();
$res = $stmt->get_result();
$pairs = [];
while ($row = $res->fetch_assoc()) {
    $pairs[] = $row;
}

$results = [];

foreach ($pairs as $p) {
    $terminalId = (int)$p['terminal_id'];
    $routeId = $p['route_id'];

    // Fetch forecasts
    $stmtF = $db->prepare("
        SELECT ts, forecast_trips 
        FROM demand_forecasts 
        WHERE terminal_id=? AND route_id=? 
        AND ts >= DATE_SUB(NOW(), INTERVAL ? HOUR) 
        AND ts <= NOW()
    ");
    $stmtF->bind_param('isi', $terminalId, $routeId, $lookback);
    $stmtF->execute();
    $resF = $stmtF->get_result();
    $fmap = [];
    while ($row = $resF->fetch_assoc()) {
        $ts = $row['ts'];
        $fmap[$ts] = (double)$row['forecast_trips'];
    }

    // Fetch actuals
    $stmtA = $db->prepare("
        SELECT 
            FROM_UNIXTIME(FLOOR(UNIX_TIMESTAMP(l.time_in)/?)*?) AS slot_ts, 
            COUNT(*) AS trips 
        FROM terminal_logs l 
        JOIN vehicles v ON v.plate_number=l.vehicle_plate 
        WHERE l.activity_type='Dispatch' 
        AND l.terminal_id=? AND v.route_id=? 
        AND l.time_in >= DATE_SUB(NOW(), INTERVAL ? HOUR) 
        AND l.time_in <= NOW() 
        GROUP BY slot_ts
    ");
    $stmtA->bind_param('iiisi', $granSec, $granSec, $terminalId, $routeId, $lookback);
    $stmtA->execute();
    $resA = $stmtA->get_result();
    
    $matchCount = 0;
    $sumAbsPct = 0.0;
    $sumSq = 0.0;
    
    while ($row = $resA->fetch_assoc()) {
        $ts = $row['slot_ts'];
        $actual = (int)$row['trips'];
        
        // Try exact match, or fallback to closest hour if granularity matches? 
        // For now, assume timestamps align if generated by same gran
        if (isset($fmap[$ts])) {
            $forecast = $fmap[$ts];
            $diff = $actual - $forecast;
            $sumSq += $diff * $diff;
            
            $den = $actual <= 0 ? 1.0 : $actual;
            $sumAbsPct += abs($diff) / $den;
            $matchCount++;
        }
    }

    if ($matchCount > 0) {
        $mape = $sumAbsPct / $matchCount;
        $rmse = sqrt($sumSq / $matchCount);
        $acc = max(0.0, 1.0 - $mape);
        
        $results[] = [
            'terminal_id' => $terminalId,
            'route_id' => $routeId,
            'samples' => $matchCount,
            'mape' => round($mape * 100, 1),
            'rmse' => round($rmse, 2),
            'accuracy' => round($acc * 100, 1)
        ];
    } else {
        // Include with nulls if no overlap found yet
        $results[] = [
            'terminal_id' => $terminalId,
            'route_id' => $routeId,
            'samples' => 0,
            'mape' => null,
            'rmse' => null,
            'accuracy' => null
        ];
    }
}

echo json_encode(['ok'=>true, 'lookback_hours'=>$lookback, 'results'=>$results]);
?>
